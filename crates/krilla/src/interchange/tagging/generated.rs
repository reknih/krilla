// Generated tag definitions for PDF structure elements.
// This file is auto-generated by scripts/generate_tags.py - DO NOT EDIT MANUALLY!

// Types are imported in tag.rs


/// Trait for accessing common tag attributes.
pub trait TagTrait {
    /// Get the tag identifier.
    fn id(&self) -> Option<&TagId>;
    /// Get the language.
    fn lang(&self) -> Option<&str>;
    /// Get the alternate text.
    fn alt_text(&self) -> Option<&str>;
    /// Get the expanded form.
    fn expanded(&self) -> Option<&str>;
    /// Get the actual text.
    fn actual_text(&self) -> Option<&str>;
    /// Get the location.
    fn location(&self) -> Option<&Location>;
    /// Get the placement.
    fn placement(&self) -> Option<&Placement>;
    /// Get the writing mode.
    fn writing_mode(&self) -> Option<&WritingMode>;
    
    /// Get the title.
    fn title(&self) -> Option<&str>;
    /// Get the headers.
    fn headers(&self) -> Option<&[TagId]>;
    
    /// Get the general attributes.
    fn attrs(&self) -> BSet<Attr>;
    /// Get the list attributes.
    fn list_attrs(&self) -> BSet<ListAttr>;
    /// Get the table attributes.
    fn table_attrs(&self) -> BSet<TableAttr>;
    /// Get the layout attributes.
    fn layout_attrs(&self) -> BSet<LayoutAttr>;
}

// Re-export internal types for use in crate
pub(crate) use crate::interchange::tagging::tag::internal::{Attr, ListAttr, TableAttr, LayoutAttr, BSet};

/// A part of a document that may contain multiple articles or sections.
#[derive(Clone, Debug, PartialEq)]
pub struct PartTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl PartTag {
    /// Create a new Part tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl PartTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for PartTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for PartTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// An article with largely self-contained content.
#[derive(Clone, Debug, PartialEq)]
pub struct ArticleTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl ArticleTag {
    /// Create a new Article tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl ArticleTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for ArticleTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for ArticleTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Section of a larger document.
#[derive(Clone, Debug, PartialEq)]
pub struct SectionTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl SectionTag {
    /// Create a new Section tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl SectionTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for SectionTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for SectionTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A paragraph-level quote.
#[derive(Clone, Debug, PartialEq)]
pub struct BlockQuoteTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl BlockQuoteTag {
    /// Create a new BlockQuote tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl BlockQuoteTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for BlockQuoteTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for BlockQuoteTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// An image or figure caption. /// /// **Best Practice**: In the tag tree, this should appear as a sibling after the image (or other) content it describes.
#[derive(Clone, Debug, PartialEq)]
pub struct CaptionTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl CaptionTag {
    /// Create a new Caption tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl CaptionTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for CaptionTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for CaptionTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Table of contents. /// /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
#[derive(Clone, Debug, PartialEq)]
pub struct TOCTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TOCTag {
    /// Create a new TOC tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TOCTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TOCTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TOCTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Item in the table of contents. /// /// **Best Practice**: Should only appear within a TOC. Should only consist of labels, references, paragraphs and TOCs.
#[derive(Clone, Debug, PartialEq)]
pub struct TOCITag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TOCITag {
    /// Create a new TOCI tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TOCITag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TOCITag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TOCITag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Index of the key terms in the document. /// /// **Best Practice**: Should contain a sequence of text accompanied by reference elements pointing to their occurrence in the text.
#[derive(Clone, Debug, PartialEq)]
pub struct IndexTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl IndexTag {
    /// Create a new Index tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl IndexTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for IndexTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for IndexTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A paragraph.
#[derive(Clone, Debug, PartialEq)]
pub struct PTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl PTag {
    /// Create a new P tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl PTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for PTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for PTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Heading level 'n', including an optional title of the heading. /// /// The title is required for some export modes, like for example PDF/UA.
#[derive(Clone, Debug, PartialEq)]
pub struct HnTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The heading level
    pub level: NonZeroU32,
}

impl HnTag {
    /// Create a new Hn tag.
    pub fn new(level: NonZeroU32) -> Self {
        Self {
            level,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl HnTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs.items.push(Attr::HeadingLevel(self.level));
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}

impl TagTrait for HnTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A list. /// /// **Best practice**: Should consist of an optional caption followed by list items.
#[derive(Clone, Debug, PartialEq)]
pub struct LTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The list numbering style
    pub numbering: ListNumbering,
}

impl LTag {
    /// Create a new L tag.
    pub fn new(numbering: ListNumbering) -> Self {
        Self {
            numbering,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl LTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {
        let mut attrs = BSet::new();
        attrs.items.push(ListAttr::Numbering(self.numbering));
        attrs
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}

impl TagTrait for LTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A list item. /// /// **Best practice**: Should consist of one or more list labels and/or list bodies.
#[derive(Clone, Debug, PartialEq)]
pub struct LITag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl LITag {
    /// Create a new LI tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl LITag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for LITag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for LITag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Label for a list item.
#[derive(Clone, Debug, PartialEq)]
pub struct LblTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl LblTag {
    /// Create a new Lbl tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl LblTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for LblTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for LblTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Description of the list item.
#[derive(Clone, Debug, PartialEq)]
pub struct LBodyTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl LBodyTag {
    /// Create a new LBody tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl LBodyTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for LBodyTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for LBodyTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table, with an optional summary describing the purpose and structure. /// /// **Best practice**: Should consist of an optional table header row, one or more table body elements and an optional table footer. Can have caption as the first or last child.
#[derive(Clone, Debug, PartialEq)]
pub struct TableTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The summary attribute
    pub summary: Option<String>,
    /// The bbox attribute
    pub bbox: Option<Rect>,
    /// The width attribute
    pub width: Option<f32>,
    /// The height attribute
    pub height: Option<f32>,
}

impl TableTag {
    /// Create a new Table tag.
    pub fn new() -> Self {
        Self {
            summary: None,
            bbox: None,
            width: None,
            height: None,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// Set the summary
    pub fn with_summary(mut self, summary: String) -> Self {
        self.summary = Some(summary);
        self
    }

    /// Set the bbox
    pub fn with_bbox(mut self, bbox: Rect) -> Self {
        self.bbox = Some(bbox);
        self
    }

    /// Set the width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }

    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TableTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {
        let mut attrs = BSet::new();
        if let Some(ref summary) = self.summary {
            attrs.items.push(TableAttr::Summary(summary.clone()));
        }
        attrs
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        if let Some(ref bbox) = self.bbox {
            attrs.items.push(LayoutAttr::BBox(*bbox));
        }
        if let Some(width) = self.width {
            attrs.items.push(LayoutAttr::Width(width));
        }
        if let Some(height) = self.height {
            attrs.items.push(LayoutAttr::Height(height));
        }
        attrs
    }
}
impl Default for TableTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TableTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table row. /// /// **Best practice**: May contain table headers cells and table data cells.
#[derive(Clone, Debug, PartialEq)]
pub struct TRTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TRTag {
    /// Create a new TR tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TRTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TRTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TRTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table header cell.
#[derive(Clone, Debug, PartialEq)]
pub struct THTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The scope of this header cell
    pub scope: TableHeaderScope,
    /// The headers attribute
    pub headers: Option<SmallVec<[TagId; 1]>>,
    /// The span attribute
    pub span: Option<TableCellSpan>,
    /// The width attribute
    pub width: Option<f32>,
    /// The height attribute
    pub height: Option<f32>,
}

impl THTag {
    /// Create a new TH tag.
    pub fn new(scope: TableHeaderScope) -> Self {
        Self {
            scope,
            headers: None,
            span: None,
            width: None,
            height: None,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// Set the headers
    pub fn with_headers(mut self, headers: SmallVec<[TagId; 1]>) -> Self {
        self.headers = Some(headers);
        self
    }

    /// Set the span
    pub fn with_span(mut self, span: TableCellSpan) -> Self {
        self.span = Some(span);
        self
    }

    /// Set the width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }

    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl THTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {
        let mut attrs = BSet::new();
        attrs.items.push(TableAttr::HeaderScope(self.scope));
        if let Some(ref headers) = self.headers {
            attrs.items.push(TableAttr::CellHeaders(headers.clone()));
        }
        if let Some(ref span) = self.span {
            attrs.items.push(TableAttr::CellSpan(*span));
        }
        attrs
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        if let Some(width) = self.width {
            attrs.items.push(LayoutAttr::Width(width));
        }
        if let Some(height) = self.height {
            attrs.items.push(LayoutAttr::Height(height));
        }
        attrs
    }
}

impl TagTrait for THTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { self.headers.as_ref().map(|v| v.as_slice()) }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table data cell.
#[derive(Clone, Debug, PartialEq)]
pub struct TDTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The headers attribute
    pub headers: Option<SmallVec<[TagId; 1]>>,
    /// The span attribute
    pub span: Option<TableCellSpan>,
    /// The width attribute
    pub width: Option<f32>,
    /// The height attribute
    pub height: Option<f32>,
}

impl TDTag {
    /// Create a new TD tag.
    pub fn new() -> Self {
        Self {
            headers: None,
            span: None,
            width: None,
            height: None,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// Set the headers
    pub fn with_headers(mut self, headers: SmallVec<[TagId; 1]>) -> Self {
        self.headers = Some(headers);
        self
    }

    /// Set the span
    pub fn with_span(mut self, span: TableCellSpan) -> Self {
        self.span = Some(span);
        self
    }

    /// Set the width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }

    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TDTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {
        let mut attrs = BSet::new();
        if let Some(ref headers) = self.headers {
            attrs.items.push(TableAttr::CellHeaders(headers.clone()));
        }
        if let Some(ref span) = self.span {
            attrs.items.push(TableAttr::CellSpan(*span));
        }
        attrs
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        if let Some(width) = self.width {
            attrs.items.push(LayoutAttr::Width(width));
        }
        if let Some(height) = self.height {
            attrs.items.push(LayoutAttr::Height(height));
        }
        attrs
    }
}
impl Default for TDTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TDTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { self.headers.as_ref().map(|v| v.as_slice()) }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table header row group.
#[derive(Clone, Debug, PartialEq)]
pub struct THeadTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl THeadTag {
    /// Create a new THead tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl THeadTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for THeadTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for THeadTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table data row group.
#[derive(Clone, Debug, PartialEq)]
pub struct TBodyTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TBodyTag {
    /// Create a new TBody tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TBodyTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TBodyTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TBodyTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A table footer row group.
#[derive(Clone, Debug, PartialEq)]
pub struct TFootTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TFootTag {
    /// Create a new TFoot tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TFootTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TFootTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TFootTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// An inline quotation.
#[derive(Clone, Debug, PartialEq)]
pub struct InlineQuoteTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl InlineQuoteTag {
    /// Create a new InlineQuote tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl InlineQuoteTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for InlineQuoteTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for InlineQuoteTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A foot- or endnote, potentially referred to from within the text. /// /// **Best practice**: It may have a label as a child.
#[derive(Clone, Debug, PartialEq)]
pub struct NoteTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl NoteTag {
    /// Create a new Note tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl NoteTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for NoteTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for NoteTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A reference to elsewhere in the document. /// /// **Best practice**: The first child of a tag group with this tag should be a link annotation linking to a destination in the document, and the second child should consist of the children that should be associated with that reference.
#[derive(Clone, Debug, PartialEq)]
pub struct ReferenceTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl ReferenceTag {
    /// Create a new Reference tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl ReferenceTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for ReferenceTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for ReferenceTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A reference to the external source of some cited document. /// /// **Best practice**: It may have a label as a child.
#[derive(Clone, Debug, PartialEq)]
pub struct BibEntryTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl BibEntryTag {
    /// Create a new BibEntry tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl BibEntryTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for BibEntryTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for BibEntryTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Computer code.
#[derive(Clone, Debug, PartialEq)]
pub struct CodeTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl CodeTag {
    /// Create a new Code tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl CodeTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for CodeTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for CodeTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A link. /// /// **Best practice**: The first child of a tag group with this tag should be a link annotation linking to an URL, and the second child should consist of the children that should be associated with that link.
#[derive(Clone, Debug, PartialEq)]
pub struct LinkTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl LinkTag {
    /// Create a new Link tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl LinkTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for LinkTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for LinkTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// An association between an annotation and the content it belongs to. PDF /// /// **Best practice**: Should be used for all annotations, except for link annotations and widget annotations. The first child should be the identifier of a non-link annotation, and all other subsequent children should be content identifiers associated with that annotation.
#[derive(Clone, Debug, PartialEq)]
pub struct AnnotTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl AnnotTag {
    /// Create a new Annot tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl AnnotTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for AnnotTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for AnnotTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// Item of graphical content. /// /// Providing alt_text is required in some export modes, like for example PDF/UA1.
#[derive(Clone, Debug, PartialEq)]
pub struct FigureTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The bbox attribute
    pub bbox: Option<Rect>,
    /// The width attribute
    pub width: Option<f32>,
    /// The height attribute
    pub height: Option<f32>,
}

impl FigureTag {
    /// Create a new Figure tag.
    pub fn new() -> Self {
        Self {
            bbox: None,
            width: None,
            height: None,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// Set the bbox
    pub fn with_bbox(mut self, bbox: Rect) -> Self {
        self.bbox = Some(bbox);
        self
    }

    /// Set the width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }

    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl FigureTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        if let Some(ref bbox) = self.bbox {
            attrs.items.push(LayoutAttr::BBox(*bbox));
        }
        if let Some(width) = self.width {
            attrs.items.push(LayoutAttr::Width(width));
        }
        if let Some(height) = self.height {
            attrs.items.push(LayoutAttr::Height(height));
        }
        attrs
    }
}
impl Default for FigureTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for FigureTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A mathematical formula. /// /// Providing alt_text is required in some export modes, like for example PDF/UA1.
#[derive(Clone, Debug, PartialEq)]
pub struct FormulaTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
    /// The bbox attribute
    pub bbox: Option<Rect>,
    /// The width attribute
    pub width: Option<f32>,
    /// The height attribute
    pub height: Option<f32>,
}

impl FormulaTag {
    /// Create a new Formula tag.
    pub fn new() -> Self {
        Self {
            bbox: None,
            width: None,
            height: None,
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// Set the bbox
    pub fn with_bbox(mut self, bbox: Rect) -> Self {
        self.bbox = Some(bbox);
        self
    }

    /// Set the width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }

    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl FormulaTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        if let Some(ref bbox) = self.bbox {
            attrs.items.push(LayoutAttr::BBox(*bbox));
        }
        if let Some(width) = self.width {
            attrs.items.push(LayoutAttr::Width(width));
        }
        if let Some(height) = self.height {
            attrs.items.push(LayoutAttr::Height(height));
        }
        attrs
    }
}
impl Default for FormulaTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for FormulaTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A date or time.
#[derive(Clone, Debug, PartialEq)]
pub struct DatetimeTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl DatetimeTag {
    /// Create a new Datetime tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl DatetimeTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for DatetimeTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for DatetimeTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A list of terms.
#[derive(Clone, Debug, PartialEq)]
pub struct TermsTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TermsTag {
    /// Create a new Terms tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TermsTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TermsTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TermsTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A title.
#[derive(Clone, Debug, PartialEq)]
pub struct TitleTag {
    /// The tag identifier
    pub id: Option<TagId>,
    /// The language of this tag
    pub lang: Option<String>,
    /// An optional alternate text that describes the text
    pub alt_text: Option<String>,
    /// If the content is an abbreviation, the expanded form
    pub expanded: Option<String>,
    /// The actual text represented by the content
    pub actual_text: Option<String>,
    /// The location of the tag
    pub location: Option<Location>,
    /// The positioning of the element
    pub placement: Option<Placement>,
    /// The writing mode
    pub writing_mode: Option<WritingMode>,
    /// The title of the element
    pub title: Option<String>,
}

impl TitleTag {
    /// Create a new Title tag.
    pub fn new() -> Self {
        Self {
            id: None,
            lang: None,
            alt_text: None,
            expanded: None,
            actual_text: None,
            location: None,
            placement: None,
            writing_mode: None,
            title: None,
        }
    }
    /// The tag identifier
    pub fn with_id(mut self, id: TagId) -> Self {
        self.id = Some(id);
        self
    }

    /// The language of this tag
    pub fn with_lang(mut self, lang: String) -> Self {
        self.lang = Some(lang);
        self
    }

    /// An optional alternate text that describes the text
    pub fn with_alt_text(mut self, alt_text: String) -> Self {
        self.alt_text = Some(alt_text);
        self
    }

    /// If the content is an abbreviation, the expanded form
    pub fn with_expanded(mut self, expanded: String) -> Self {
        self.expanded = Some(expanded);
        self
    }

    /// The actual text represented by the content
    pub fn with_actual_text(mut self, actual_text: String) -> Self {
        self.actual_text = Some(actual_text);
        self
    }

    /// The location of the tag
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// The positioning of the element
    pub fn with_placement(mut self, placement: Placement) -> Self {
        self.placement = Some(placement);
        self
    }

    /// The writing mode
    pub fn with_writing_mode(mut self, writing_mode: WritingMode) -> Self {
        self.writing_mode = Some(writing_mode);
        self
    }

    /// The title of the element
    pub fn with_title(mut self, title: String) -> Self {
        self.title = Some(title);
        self
    }
}

// Additional accessor methods for mod.rs compatibility
impl TitleTag {
    /// Get the attributes as internal BSet types.
    pub(crate) fn attrs(&self) -> BSet<Attr> {
        let mut attrs = BSet::new();
        if let Some(ref id) = self.id {
            attrs.items.push(Attr::Id(id.clone()));
        }
        if let Some(ref title) = self.title {
            attrs.items.push(Attr::Title(title.clone()));
        }
        if let Some(ref lang) = self.lang {
            attrs.items.push(Attr::Lang(lang.clone()));
        }
        if let Some(ref alt_text) = self.alt_text {
            attrs.items.push(Attr::AltText(alt_text.clone()));
        }
        if let Some(ref expanded) = self.expanded {
            attrs.items.push(Attr::Expanded(expanded.clone()));
        }
        if let Some(ref actual_text) = self.actual_text {
            attrs.items.push(Attr::ActualText(actual_text.clone()));
        }
        attrs
    }
    
    pub(crate) fn list_attrs(&self) -> BSet<ListAttr> {BSet::new()
    }
    
    pub(crate) fn table_attrs(&self) -> BSet<TableAttr> {BSet::new()
    }
    
    pub(crate) fn layout_attrs(&self) -> BSet<LayoutAttr> {
        let mut attrs = BSet::new();
        if let Some(ref placement) = self.placement {
            attrs.items.push(LayoutAttr::Placement(*placement));
        }
        if let Some(ref writing_mode) = self.writing_mode {
            attrs.items.push(LayoutAttr::WritingMode(*writing_mode));
        }
        attrs
    }
}
impl Default for TitleTag {
    fn default() -> Self {
        Self::new()
    }
}

impl TagTrait for TitleTag {
    fn id(&self) -> Option<&TagId> { self.id.as_ref() }
    fn lang(&self) -> Option<&str> { self.lang.as_deref() }
    fn alt_text(&self) -> Option<&str> { self.alt_text.as_deref() }
    fn expanded(&self) -> Option<&str> { self.expanded.as_deref() }
    fn actual_text(&self) -> Option<&str> { self.actual_text.as_deref() }
    fn location(&self) -> Option<&Location> { self.location.as_ref() }
    fn placement(&self) -> Option<&Placement> { self.placement.as_ref() }
    fn writing_mode(&self) -> Option<&WritingMode> { self.writing_mode.as_ref() }
    fn title(&self) -> Option<&str> { self.title.as_deref() }
    fn headers(&self) -> Option<&[TagId]> { None }
    
    fn attrs(&self) -> BSet<Attr> { self.attrs() }
    fn list_attrs(&self) -> BSet<ListAttr> { self.list_attrs() }
    fn table_attrs(&self) -> BSet<TableAttr> { self.table_attrs() }
    fn layout_attrs(&self) -> BSet<LayoutAttr> { self.layout_attrs() }
}

/// A tag kind.
#[derive(Clone, Debug, PartialEq)]
pub enum TagKind {
    /// A part of a document that may contain multiple articles or sections.
    Part(PartTag),
    /// An article with largely self-contained content.
    Article(ArticleTag),
    /// Section of a larger document.
    Section(SectionTag),
    /// A paragraph-level quote.
    BlockQuote(BlockQuoteTag),
    /// An image or figure caption.     ///     /// **Best Practice**: In the tag tree, this should appear as a sibling after the image (or other) content it describes.
    Caption(CaptionTag),
    /// Table of contents.     ///     /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    TOC(TOCTag),
    /// Item in the table of contents.     ///     /// **Best Practice**: Should only appear within a TOC. Should only consist of labels, references, paragraphs and TOCs.
    TOCI(TOCITag),
    /// Index of the key terms in the document.     ///     /// **Best Practice**: Should contain a sequence of text accompanied by reference elements pointing to their occurrence in the text.
    Index(IndexTag),
    /// A paragraph.
    P(PTag),
    /// Heading level 'n', including an optional title of the heading.     ///     /// The title is required for some export modes, like for example PDF/UA.
    Hn(HnTag),
    /// A list.     ///     /// **Best practice**: Should consist of an optional caption followed by list items.
    L(LTag),
    /// A list item.     ///     /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    LI(LITag),
    /// Label for a list item.
    Lbl(LblTag),
    /// Description of the list item.
    LBody(LBodyTag),
    /// A table, with an optional summary describing the purpose and structure.     ///     /// **Best practice**: Should consist of an optional table header row, one or more table body elements and an optional table footer. Can have caption as the first or last child.
    Table(TableTag),
    /// A table row.     ///     /// **Best practice**: May contain table headers cells and table data cells.
    TR(TRTag),
    /// A table header cell.
    TH(THTag),
    /// A table data cell.
    TD(TDTag),
    /// A table header row group.
    THead(THeadTag),
    /// A table data row group.
    TBody(TBodyTag),
    /// A table footer row group.
    TFoot(TFootTag),
    /// An inline quotation.
    InlineQuote(InlineQuoteTag),
    /// A foot- or endnote, potentially referred to from within the text.     ///     /// **Best practice**: It may have a label as a child.
    Note(NoteTag),
    /// A reference to elsewhere in the document.     ///     /// **Best practice**: The first child of a tag group with this tag should be a link annotation linking to a destination in the document, and the second child should consist of the children that should be associated with that reference.
    Reference(ReferenceTag),
    /// A reference to the external source of some cited document.     ///     /// **Best practice**: It may have a label as a child.
    BibEntry(BibEntryTag),
    /// Computer code.
    Code(CodeTag),
    /// A link.     ///     /// **Best practice**: The first child of a tag group with this tag should be a link annotation linking to an URL, and the second child should consist of the children that should be associated with that link.
    Link(LinkTag),
    /// An association between an annotation and the content it belongs to. PDF     ///     /// **Best practice**: Should be used for all annotations, except for link annotations and widget annotations. The first child should be the identifier of a non-link annotation, and all other subsequent children should be content identifiers associated with that annotation.
    Annot(AnnotTag),
    /// Item of graphical content.     ///     /// Providing alt_text is required in some export modes, like for example PDF/UA1.
    Figure(FigureTag),
    /// A mathematical formula.     ///     /// Providing alt_text is required in some export modes, like for example PDF/UA1.
    Formula(FormulaTag),
    /// A date or time.
    Datetime(DatetimeTag),
    /// A list of terms.
    Terms(TermsTag),
    /// A title.
    Title(TitleTag),
}

impl TagKind {
    /// Get a reference to the inner tag's global attributes.
    pub fn inner(&self) -> &dyn TagTrait {
        match self {
            TagKind::Part(tag) => tag,
            TagKind::Article(tag) => tag,
            TagKind::Section(tag) => tag,
            TagKind::BlockQuote(tag) => tag,
            TagKind::Caption(tag) => tag,
            TagKind::TOC(tag) => tag,
            TagKind::TOCI(tag) => tag,
            TagKind::Index(tag) => tag,
            TagKind::P(tag) => tag,
            TagKind::Hn(tag) => tag,
            TagKind::L(tag) => tag,
            TagKind::LI(tag) => tag,
            TagKind::Lbl(tag) => tag,
            TagKind::LBody(tag) => tag,
            TagKind::Table(tag) => tag,
            TagKind::TR(tag) => tag,
            TagKind::TH(tag) => tag,
            TagKind::TD(tag) => tag,
            TagKind::THead(tag) => tag,
            TagKind::TBody(tag) => tag,
            TagKind::TFoot(tag) => tag,
            TagKind::InlineQuote(tag) => tag,
            TagKind::Note(tag) => tag,
            TagKind::Reference(tag) => tag,
            TagKind::BibEntry(tag) => tag,
            TagKind::Code(tag) => tag,
            TagKind::Link(tag) => tag,
            TagKind::Annot(tag) => tag,
            TagKind::Figure(tag) => tag,
            TagKind::Formula(tag) => tag,
            TagKind::Datetime(tag) => tag,
            TagKind::Terms(tag) => tag,
            TagKind::Title(tag) => tag,
        }
    }

    /// Get the heading level if this is an Hn tag.
    pub(crate) fn heading_level(&self) -> Option<NonZeroU32> {
        match self {
            TagKind::Hn(tag) => Some(tag.level),
            _ => None,
        }
    }
    /// Get the list numbering if this is an L tag.
    pub(crate) fn list_numbering(&self) -> Option<ListNumbering> {
        match self {
            TagKind::L(tag) => Some(tag.numbering),
            _ => None,
        }
    }
    /// Get the header scope if this is a TH tag.
    pub(crate) fn header_scope(&self) -> Option<TableHeaderScope> {
        match self {
            TagKind::TH(tag) => Some(tag.scope),
            _ => None,
        }
    }
    /// Check if this tag should have alt text.
    pub(crate) fn should_have_alt(&self) -> bool {
        matches!(self, TagKind::Figure(_) | TagKind::Formula(_))
    }
    
    /// Check if this tag can have a title.
    pub(crate) fn can_have_title(&self) -> bool {
        matches!(self, TagKind::Hn(_))
    }
}

impl From<PartTag> for TagKind {
    fn from(tag: PartTag) -> Self {
        TagKind::Part(tag)
    }
}

impl From<ArticleTag> for TagKind {
    fn from(tag: ArticleTag) -> Self {
        TagKind::Article(tag)
    }
}

impl From<SectionTag> for TagKind {
    fn from(tag: SectionTag) -> Self {
        TagKind::Section(tag)
    }
}

impl From<BlockQuoteTag> for TagKind {
    fn from(tag: BlockQuoteTag) -> Self {
        TagKind::BlockQuote(tag)
    }
}

impl From<CaptionTag> for TagKind {
    fn from(tag: CaptionTag) -> Self {
        TagKind::Caption(tag)
    }
}

impl From<TOCTag> for TagKind {
    fn from(tag: TOCTag) -> Self {
        TagKind::TOC(tag)
    }
}

impl From<TOCITag> for TagKind {
    fn from(tag: TOCITag) -> Self {
        TagKind::TOCI(tag)
    }
}

impl From<IndexTag> for TagKind {
    fn from(tag: IndexTag) -> Self {
        TagKind::Index(tag)
    }
}

impl From<PTag> for TagKind {
    fn from(tag: PTag) -> Self {
        TagKind::P(tag)
    }
}

impl From<HnTag> for TagKind {
    fn from(tag: HnTag) -> Self {
        TagKind::Hn(tag)
    }
}

impl From<LTag> for TagKind {
    fn from(tag: LTag) -> Self {
        TagKind::L(tag)
    }
}

impl From<LITag> for TagKind {
    fn from(tag: LITag) -> Self {
        TagKind::LI(tag)
    }
}

impl From<LblTag> for TagKind {
    fn from(tag: LblTag) -> Self {
        TagKind::Lbl(tag)
    }
}

impl From<LBodyTag> for TagKind {
    fn from(tag: LBodyTag) -> Self {
        TagKind::LBody(tag)
    }
}

impl From<TableTag> for TagKind {
    fn from(tag: TableTag) -> Self {
        TagKind::Table(tag)
    }
}

impl From<TRTag> for TagKind {
    fn from(tag: TRTag) -> Self {
        TagKind::TR(tag)
    }
}

impl From<THTag> for TagKind {
    fn from(tag: THTag) -> Self {
        TagKind::TH(tag)
    }
}

impl From<TDTag> for TagKind {
    fn from(tag: TDTag) -> Self {
        TagKind::TD(tag)
    }
}

impl From<THeadTag> for TagKind {
    fn from(tag: THeadTag) -> Self {
        TagKind::THead(tag)
    }
}

impl From<TBodyTag> for TagKind {
    fn from(tag: TBodyTag) -> Self {
        TagKind::TBody(tag)
    }
}

impl From<TFootTag> for TagKind {
    fn from(tag: TFootTag) -> Self {
        TagKind::TFoot(tag)
    }
}

impl From<InlineQuoteTag> for TagKind {
    fn from(tag: InlineQuoteTag) -> Self {
        TagKind::InlineQuote(tag)
    }
}

impl From<NoteTag> for TagKind {
    fn from(tag: NoteTag) -> Self {
        TagKind::Note(tag)
    }
}

impl From<ReferenceTag> for TagKind {
    fn from(tag: ReferenceTag) -> Self {
        TagKind::Reference(tag)
    }
}

impl From<BibEntryTag> for TagKind {
    fn from(tag: BibEntryTag) -> Self {
        TagKind::BibEntry(tag)
    }
}

impl From<CodeTag> for TagKind {
    fn from(tag: CodeTag) -> Self {
        TagKind::Code(tag)
    }
}

impl From<LinkTag> for TagKind {
    fn from(tag: LinkTag) -> Self {
        TagKind::Link(tag)
    }
}

impl From<AnnotTag> for TagKind {
    fn from(tag: AnnotTag) -> Self {
        TagKind::Annot(tag)
    }
}

impl From<FigureTag> for TagKind {
    fn from(tag: FigureTag) -> Self {
        TagKind::Figure(tag)
    }
}

impl From<FormulaTag> for TagKind {
    fn from(tag: FormulaTag) -> Self {
        TagKind::Formula(tag)
    }
}

impl From<DatetimeTag> for TagKind {
    fn from(tag: DatetimeTag) -> Self {
        TagKind::Datetime(tag)
    }
}

impl From<TermsTag> for TagKind {
    fn from(tag: TermsTag) -> Self {
        TagKind::Terms(tag)
    }
}

impl From<TitleTag> for TagKind {
    fn from(tag: TitleTag) -> Self {
        TagKind::Title(tag)
    }
}

/// Convenience constructors for tags.
pub struct Tag;

impl Tag {
    /// A part of a document that may contain multiple articles or sections.
    pub const Part: TagKind = TagKind::Part(PartTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// An article with largely self-contained content.
    pub const Article: TagKind = TagKind::Article(ArticleTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Section of a larger document.
    pub const Section: TagKind = TagKind::Section(SectionTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A paragraph-level quote.
    pub const BlockQuote: TagKind = TagKind::BlockQuote(BlockQuoteTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// An image or figure caption.
    pub const Caption: TagKind = TagKind::Caption(CaptionTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Table of contents.
    pub const TOC: TagKind = TagKind::TOC(TOCTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Item in the table of contents.
    pub const TOCI: TagKind = TagKind::TOCI(TOCITag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Index of the key terms in the document.
    pub const Index: TagKind = TagKind::Index(IndexTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A paragraph.
    pub const P: TagKind = TagKind::P(PTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Heading level 'n', including an optional title of the heading.
    pub fn Hn(level: NonZeroU32) -> TagKind {
        TagKind::Hn(HnTag::new(level))
    }
    /// A list.
    pub fn L(numbering: ListNumbering) -> TagKind {
        TagKind::L(LTag::new(numbering))
    }
    /// A list item.
    pub const LI: TagKind = TagKind::LI(LITag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Label for a list item.
    pub const Lbl: TagKind = TagKind::Lbl(LblTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Description of the list item.
    pub const LBody: TagKind = TagKind::LBody(LBodyTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A table, with an optional summary describing the purpose and structure.
    pub const Table: TagKind = TagKind::Table(TableTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
        summary: None,
        bbox: None,
        width: None,
        height: None,
    });
    /// A table row.
    pub const TR: TagKind = TagKind::TR(TRTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A table header cell.
    pub fn TH(scope: TableHeaderScope) -> TagKind {
        TagKind::TH(THTag::new(scope))
    }
    /// A table data cell.
    pub const TD: TagKind = TagKind::TD(TDTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
        headers: None,
        span: None,
        width: None,
        height: None,
    });
    /// A table header row group.
    pub const THead: TagKind = TagKind::THead(THeadTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A table data row group.
    pub const TBody: TagKind = TagKind::TBody(TBodyTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A table footer row group.
    pub const TFoot: TagKind = TagKind::TFoot(TFootTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// An inline quotation.
    pub const InlineQuote: TagKind = TagKind::InlineQuote(InlineQuoteTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A foot- or endnote, potentially referred to from within the text.
    pub const Note: TagKind = TagKind::Note(NoteTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A reference to elsewhere in the document.
    pub const Reference: TagKind = TagKind::Reference(ReferenceTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A reference to the external source of some cited document.
    pub const BibEntry: TagKind = TagKind::BibEntry(BibEntryTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Computer code.
    pub const Code: TagKind = TagKind::Code(CodeTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A link.
    pub const Link: TagKind = TagKind::Link(LinkTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// An association between an annotation and the content it belongs to. PDF
    pub const Annot: TagKind = TagKind::Annot(AnnotTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// Item of graphical content.
    pub const Figure: TagKind = TagKind::Figure(FigureTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
        bbox: None,
        width: None,
        height: None,
    });
    /// A mathematical formula.
    pub const Formula: TagKind = TagKind::Formula(FormulaTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
        bbox: None,
        width: None,
        height: None,
    });
    /// A date or time.
    pub const Datetime: TagKind = TagKind::Datetime(DatetimeTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A list of terms.
    pub const Terms: TagKind = TagKind::Terms(TermsTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
    /// A title.
    pub const Title: TagKind = TagKind::Title(TitleTag {
        id: None,
        lang: None,
        alt_text: None,
        expanded: None,
        actual_text: None,
        location: None,
        placement: None,
        writing_mode: None,
        title: None,
    });
}